# Chapter 5: How to Process and Transform Data?

## Problem Introduction

You've learned how to create workflows and connect various third-party services. Now, you may have discovered a new challenge: data formats from different sources are often inconsistent. Some data is nested JSON, some are arrays, some field names don't match your needs, and some data needs calculation or formatting.

"How do I extract the data I need from complex JSON? How do I merge multiple data sources? How do I filter data based on conditions? How do I format dates and numbers?" These data processing questions might confuse you. But don't worry, N8N provides powerful data processing capabilities, including multiple data operation nodes and flexible expression language.

This chapter will explain N8N's data processing capabilities in detail, starting from basic JSON data structures, gradually learning how to use Set, Code, Function and other nodes to process and transform data, master the usage of expression language, and learn advanced operations like data merging, filtering, and sorting. Through this chapter, you'll be able to handle any complex data scenarios and make data truly work for you.

## Core Concepts

### N8N's Data Structure

Understanding N8N's data structure is the foundation for processing data. N8N uses JSON format to pass and store data.

#### JSON Data Format

JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy to read and write.

**Basic JSON Structure**:
```json
{
  "json": {
    "name": "John",
    "age": 30,
    "email": "john@example.com"
  }
}
```

**Nested JSON Structure**:
```json
{
  "json": {
    "user": {
      "name": "John",
      "address": {
        "city": "Beijing",
        "country": "China"
      }
    },
    "orders": [
      {"id": 1, "amount": 100},
      {"id": 2, "amount": 200}
    ]
  }
}
```

#### Data Item

In N8N, each data item is a JSON object:
- **Single Data Item**: Contains one JSON object
- **Multiple Data Items**: Contains an array of multiple JSON objects

**Data Item Structure**:
```json
{
  "json": { /* data content */ },
  "binary": { /* binary data */ },
  "error": null
}
```

### Data Operation Nodes

N8N provides multiple nodes to process and transform data.

#### Set Node

Set node is used to add, modify, or delete data fields.

**Main Functions**:
- Add new fields
- Modify existing fields
- Delete fields
- Rename fields

**Use Cases**:
- Standardize data format
- Add calculated fields
- Rename fields to match downstream systems

#### Code Node

Code node allows you to execute JavaScript code to process data.

**Main Functions**:
- Complex data calculations
- Data transformation and formatting
- Conditional logic processing
- Array operations

**Use Cases**:
- Complex data processing logic
- Scenarios requiring loops or conditional judgment
- Custom data transformation

#### Function Node

Function node is a simplified version of Code node for quickly writing simple data processing functions.

**Main Functions**:
- Quickly write data processing functions
- Simple data transformation
- Field operations

#### Item Lists Node

Item Lists node is used to process array data.

**Main Functions**:
- Split array into multiple data items
- Merge multiple data items into array
- Array sorting and filtering

### N8N Expression Language

Expression language is a powerful tool in N8N for accessing and manipulating data.

#### Expression Syntax

Expressions are wrapped with `{{ }}`:
```javascript
{{ $json.fieldName }}
{{ $json.array[0] }}
{{ $now }}
```

#### Common Expression Functions

**String Operations**:
- `{{ $json.name.toUpperCase() }}`: Convert to uppercase
- `{{ $json.name.toLowerCase() }}`: Convert to lowercase
- `{{ $json.name.substring(0, 5) }}`: Extract substring
- `{{ $json.name.replace('old', 'new') }}`: Replace string

**Number Operations**:
- `{{ $json.price.toFixed(2) }}`: Keep 2 decimal places
- `{{ $json.quantity + 1 }}`: Addition
- `{{ $json.total / $json.count }}`: Division

**Date Operations**:
- `{{ $now }}`: Current time
- `{{ $now.toISOString() }}`: ISO format date
- `{{ $json.date.format('YYYY-MM-DD') }}`: Format date

**Array Operations**:
- `{{ $json.items.length }}`: Array length
- `{{ $json.items[0] }}`: First element
- `{{ $json.items.filter(item => item.active) }}`: Filter array

## Detailed Tutorial

### Step 1: Understand JSON Data Structure

Before starting to process data, let's first deeply understand JSON data structure.

#### 1.1 Basic JSON Structure

JSON consists of key-value pairs:
```json
{
  "key": "value",
  "number": 123,
  "boolean": true,
  "array": [1, 2, 3],
  "object": {
    "nested": "value"
  }
}
```

#### 1.2 Access JSON Data

In N8N, use expressions to access JSON data:

**Access Simple Fields**:
```javascript
{{ $json.name }}
{{ $json.age }}
```

**Access Nested Fields**:
```javascript
{{ $json.user.name }}
{{ $json.user.address.city }}
```

**Access Array Elements**:
```javascript
{{ $json.items[0] }}
{{ $json.items[0].name }}
```

**Access Array Length**:
```javascript
{{ $json.items.length }}
```

#### 1.3 Data Types

N8N supports multiple data types:
- **String**: `"text"`
- **Number**: `123`, `45.67`
- **Boolean**: `true`, `false`
- **Array**: `[1, 2, 3]`
- **Object**: `{"key": "value"}`
- **Null**: `null`

### Step 2: Use Set Node to Process Data

Set node is one of the most commonly used data operation nodes.

#### 2.1 Add Fields

1. **Add Set Node**
   - Add Set node in workflow
   - Connect to data source node

2. **Configure Set Node**
   - **Keep Only Set Fields**: Uncheck (keep original fields)
   - **Values to Set**: Click "Add Value"
     - **Name**: `fullName`
     - **Value**: `{{ $json.firstName }} {{ $json.lastName }}`

3. **Save Configuration**

**Example**:
- Input data: `{"firstName": "John", "lastName": "Doe"}`
- Set node adds: `fullName: "John Doe"`
- Output data: `{"firstName": "John", "lastName": "Doe", "fullName": "John Doe"}`

#### 2.2 Modify Fields

Use Set node to modify existing fields:
- **Name**: `age`
- **Value**: `{{ $json.age + 1 }}`

#### 2.3 Delete Fields

Set **Keep Only Set Fields** to true to only keep set fields.

#### 2.4 Rename Fields

1. Add new field (with new name)
2. Set **Keep Only Set Fields** to true
3. Only keep needed fields

### Step 3: Use Code Node to Process Complex Logic

Code node allows you to write JavaScript code to process data.

#### 3.1 Basic Usage

1. **Add Code Node**
   - Add Code node in workflow

2. **Select Execution Mode**
   - **Run Once for All Items**: Process all data items
   - **Run Once for Each Item**: Execute for each data item

3. **Write Code**
```javascript
// Get input data
const items = $input.all();

// Process data
const processedItems = items.map(item => {
  return {
    json: {
      name: item.json.name.toUpperCase(),
      age: item.json.age,
      category: item.json.age >= 18 ? 'adult' : 'minor'
    }
  };
});

// Return processed data
return processedItems;
```

#### 3.2 Common Operations

**Data Transformation**:
```javascript
const items = $input.all();
return items.map(item => ({
  json: {
    ...item.json,
    price: parseFloat(item.json.price).toFixed(2),
    date: new Date(item.json.date).toISOString()
  }
}));
```

**Data Filtering**:
```javascript
const items = $input.all();
return items.filter(item => item.json.status === 'active');
```

**Data Calculation**:
```javascript
const items = $input.all();
const total = items.reduce((sum, item) => sum + item.json.amount, 0);
return [{ json: { total } }];
```

### Step 4: Use Expression Language

Expression language is the core tool in N8N for accessing and manipulating data.

#### 4.1 Basic Expressions

**Access Data**:
```javascript
{{ $json.name }}              // Access field
{{ $json.user.email }}        // Access nested field
{{ $json.items[0] }}          // Access array element
```

**Use Functions**:
```javascript
{{ $json.name.toUpperCase() }}           // String to uppercase
{{ $json.price.toFixed(2) }}             // Number formatting
{{ $json.date.format('YYYY-MM-DD') }}     // Date formatting
```

#### 4.2 Conditional Expressions

**Ternary Operator**:
```javascript
{{ $json.age >= 18 ? 'adult' : 'minor' }}
{{ $json.status === 'active' ? $json.name : 'N/A' }}
```

**Logical Operators**:
```javascript
{{ $json.status === 'active' && $json.verified === true }}
{{ $json.role === 'admin' || $json.role === 'moderator' }}
```

#### 4.3 String Operations

**String Methods**:
```javascript
{{ $json.name.length }}                    // String length
{{ $json.name.substring(0, 10) }}         // Extract substring
{{ $json.name.replace('old', 'new') }}     // Replace string
{{ $json.email.split('@')[0] }}            // Split string
```

#### 4.4 Math Operations

**Basic Operations**:
```javascript
{{ $json.price + 10 }}                     // Addition
{{ $json.total - $json.discount }}         // Subtraction
{{ $json.quantity * $json.price }}        // Multiplication
{{ $json.total / $json.count }}            // Division
{{ $json.number % 2 }}                     // Modulo
```

**Math Functions**:
```javascript
{{ Math.round($json.price) }}              // Round
{{ Math.floor($json.price) }}              // Floor
{{ Math.ceil($json.price) }}               // Ceil
{{ Math.max($json.a, $json.b) }}          // Maximum
{{ Math.min($json.a, $json.b) }}          // Minimum
```

### Step 5: Data Merging and Aggregation

Processing data from multiple data sources is a common requirement.

#### 5.1 Use Merge Node

Merge node is used to merge multiple data streams.

1. **Add Merge Node**
   - Connect multiple data sources to Merge node

2. **Select Merge Mode**
   - **Merge By Index**: Merge by index
   - **Merge By Key**: Merge by key value
   - **Append**: Append data

3. **Configure Merge Rules**
   - Set merge key (if using Merge By Key)
   - Handle conflict fields

#### 5.2 Use Code Node to Merge Data

```javascript
const items1 = $input.item.json.source1;
const items2 = $input.item.json.source2;
const items3 = $input.item.json.source3;

return [{
  json: {
    ...items1,
    ...items2,
    ...items3,
    mergedAt: new Date().toISOString()
  }
}];
```

### Step 6: Data Filtering and Conditional Processing

Filtering and processing data based on conditions is an important part of data processing.

#### 6.1 Use IF Node

IF node is used to branch data based on conditions.

1. **Add IF Node**
   - Connect to data source

2. **Configure Condition**
   - **Condition**: Select condition type
   - **Value 1**: `{{ $json.status }}`
   - **Operation**: `equal`
   - **Value 2**: `active`

3. **Process Two Branches**
   - **True Branch**: Data that meets condition
   - **False Branch**: Data that doesn't meet condition

#### 6.2 Use Switch Node

Switch node is used for multi-condition branching.

1. **Add Switch Node**
2. **Configure Multiple Conditions**
   - Each condition corresponds to one output
   - Can set default output

#### 6.3 Use Code Node to Filter

```javascript
const items = $input.all();
return items.filter(item => {
  return item.json.status === 'active' && 
         item.json.amount > 100;
});
```

## Practice Exercises

### Exercise 1: Data Extraction Practice

**Task Objective**: Extract nested data from complex JSON responses, use expressions to extract array elements, create reusable data extraction templates

**Prerequisites**:
- N8N installed and running
- Understand basic JSON structure

**Detailed Steps**:

1. **Create Test Data**
   - Add Manual Trigger node
   - Add Set node, create complex JSON data:
   ```json
   {
     "company": {
       "name": "Tech Corp",
       "employees": [
         {"id": 1, "name": "John", "department": "Engineering", "salary": 5000},
         {"id": 2, "name": "Jane", "department": "Marketing", "salary": 4500},
         {"id": 3, "name": "Bob", "department": "Engineering", "salary": 6000}
       ],
       "departments": {
         "Engineering": {"budget": 100000, "head": "Alice"},
         "Marketing": {"budget": 50000, "head": "Charlie"}
       }
     }
   }
   ```

2. **Extract Nested Data**
   - Add Set node
   - Extract company name: `{{ $json.company.name }}`
   - Extract department budget: `{{ $json.company.departments.Engineering.budget }}`

3. **Extract Array Elements**
   - Add Code node
   - Extract all employee names:
   ```javascript
   const employees = $input.item.json.company.employees;
   return employees.map(emp => ({
     json: {
       employeeName: emp.name,
       department: emp.department,
       salary: emp.salary
     }
   }));
   ```

4. **Create Data Extraction Template**
   - Use Set node to create reusable template
   - Record commonly used extraction expressions
   - Create expression quick reference

**Expected Results**:
- Successfully extract nested data
- Successfully extract array elements
- Create data extraction template

**Verification Method**:
- Check if extracted data is correct
- Verify if expressions are valid
- Check if template is reusable

**Data Extraction Template Example**:

| Data Type | Expression | Description |
|-----------|------------|-------------|
| Nested Object | `{{ $json.user.profile.name }}` | Access nested field |
| First Array Element | `{{ $json.items[0] }}` | Access first array element |
| Array Length | `{{ $json.items.length }}` | Get array length |
| Array Filter | `{{ $json.items.filter(i => i.active) }}` | Filter array |

**Extended Challenge**:
- Extract data from multiple nested levels
- Handle dynamic depth nested structures
- Create generic data extraction functions

**Troubleshooting**:
- **Problem**: Expression returns undefined
  - **Solution**: Check if field path is correct, use `?.` for safe access
- **Problem**: Array access out of bounds
  - **Solution**: Check array length, use conditional judgment

### Exercise 2: Data Transformation Practice

**Task Objective**: Create workflow that fetches raw data from API, use Set node to rename fields, use Code node for data calculation and formatting

**Prerequisites**:
- Completed Exercise 1
- Have an available API (can use test API)

**Detailed Steps**:

1. **Fetch Raw Data**
   - Add Schedule Trigger node
   - Add HTTP Request node
   - Configure API URL (e.g.: `https://jsonplaceholder.typicode.com/users`)

2. **Use Set Node to Rename Fields**
   - Add Set node
   - Rename fields:
     - `name` ‚Üí `fullName`
     - `email` ‚Üí `emailAddress`
     - `address.city` ‚Üí `city`
     - `address.zipcode` ‚Üí `postalCode`

3. **Use Code Node for Data Calculation**
   - Add Code node
   - Calculate fields:
   ```javascript
   const items = $input.all();
   return items.map(item => ({
     json: {
       ...item.json,
       nameLength: item.json.fullName.length,
       emailDomain: item.json.emailAddress.split('@')[1],
       isLongName: item.json.fullName.length > 10
     }
   }));
   ```

4. **Format Data**
   - Add Set node
   - Format dates, numbers, etc.:
     - `formattedDate`: `{{ $now.format('YYYY-MM-DD HH:mm:ss') }}`
     - `formattedPrice`: `{{ $json.price.toFixed(2) }}`

5. **Test Workflow**
   - Execute workflow
   - Check data transformation results

**Expected Results**:
- Fields successfully renamed
- Data calculation correct
- Data formatting correct

**Verification Method**:
- Check if field names changed
- Verify if calculation results are correct
- Check if formatting meets requirements

**Extended Challenge**:
- Process multiple data sources
- Implement complex data transformation logic
- Add data validation

**Troubleshooting**:
- **Problem**: Field renaming fails
  - **Solution**: Check if original field name is correct, ensure using Keep Only Set Fields
- **Problem**: Calculation error
  - **Solution**: Check data types, ensure numeric types are correct

### Exercise 3: Data Merging Project

**Task Objective**: Fetch data from 3 different APIs, use Merge node to merge data, handle data conflicts and missing fields, output unified JSON format

**Prerequisites**:
- Completed Exercise 2
- Have 3 available APIs (can use test APIs)

**Detailed Steps**:

1. **Fetch Multiple Data Sources**
   - Add Manual Trigger node
   - Add 3 HTTP Request nodes (parallel):
     - API 1: User data
     - API 2: Order data
     - API 3: Product data

2. **Use Merge Node to Merge Data**
   - Add Merge node
   - Connect 3 HTTP Request nodes
   - Select merge mode: Merge By Key
   - Set merge key: `userId` or `id`

3. **Handle Data Conflicts**
   - Configure conflict handling in Merge node
   - Or use Code node to handle:
   ```javascript
   const items = $input.all();
   return items.map(item => ({
     json: {
       ...item.json.source1,
       ...item.json.source2,
       ...item.json.source3,
       // Handle conflicts: prioritize source1 data
       name: item.json.source1?.name || item.json.source2?.name || item.json.source3?.name
     }
   }));
   ```

4. **Handle Missing Fields**
   - Use Set node to add default values
   - Or use Code node:
   ```javascript
   const items = $input.all();
   return items.map(item => ({
     json: {
       id: item.json.id || 'unknown',
       name: item.json.name || 'N/A',
       status: item.json.status || 'pending',
       ...item.json
     }
   }));
   ```

5. **Output Unified Format**
   - Use Set node to standardize output format
   - Ensure all data items have same field structure

**Expected Results**:
- Successfully fetch data from 3 APIs
- Data successfully merged
- Conflicts and missing fields correctly handled
- Output unified format

**Verification Method**:
- Check if merged data is complete
- Verify if conflict handling is correct
- Check if output format is unified

**Extended Challenge**:
- Process more data sources
- Implement intelligent conflict resolution
- Add data quality checks

**Troubleshooting**:
- **Problem**: Merge keys don't match
  - **Solution**: Check key values in data sources, ensure common keys exist
- **Problem**: Data lost
  - **Solution**: Check merge mode, ensure using correct merge method

### Exercise 4: Data Filtering and Conditional Processing

**Task Objective**: Create workflow that processes 100 data records, use IF node to branch data based on conditions, count number of each case

**Prerequisites**:
- Completed previous exercises
- Understand conditional judgment

**Detailed Steps**:

1. **Create Test Data**
   - Add Manual Trigger node
   - Add Code node to generate 100 test data records:
   ```javascript
   const items = [];
   for (let i = 1; i <= 100; i++) {
     items.push({
       json: {
         id: i,
         name: `User ${i}`,
         age: Math.floor(Math.random() * 50) + 18,
         status: Math.random() > 0.5 ? 'active' : 'inactive',
         amount: Math.floor(Math.random() * 1000)
       }
     });
   }
   return items;
   ```

2. **Use IF Node to Branch**
   - Add IF node
   - Configure condition: `{{ $json.status }}` equals `active`
   - Connect two branches

3. **Process Data That Meets Condition**
   - Add processing node in True branch
   - Execute operation A (e.g., send notification)

4. **Process Data That Doesn't Meet Condition**
   - Add processing node in False branch
   - Execute operation B (e.g., log record)

5. **Count Numbers**
   - Add Code node to count:
   ```javascript
   const items = $input.all();
   const activeCount = items.filter(i => i.json.status === 'active').length;
   const inactiveCount = items.length - activeCount;
   
   return [{
     json: {
       total: items.length,
       active: activeCount,
       inactive: inactiveCount,
       activePercentage: (activeCount / items.length * 100).toFixed(2) + '%'
     }
   }];
   ```

**Expected Results**:
- Successfully process 100 data records
- Data correctly branched
- Count results accurate

**Verification Method**:
- Check if branching is correct
- Verify if count numbers are accurate
- Confirm operations A and B both executed

**Extended Challenge**:
- Use Switch node to implement multi-condition branching
- Add more complex counting logic
- Implement data grouping and counting

**Troubleshooting**:
- **Problem**: Conditional judgment inaccurate
  - **Solution**: Check data types, ensure comparison value types are consistent
- **Problem**: Count results error
  - **Solution**: Check counting logic, ensure calculation is correct

### Exercise 5: Expression Language Deep Practice

**Task Objective**: Complete 20 expression practice exercises, create personal "Expression Quick Reference", implement complex expressions

**Prerequisites**:
- Completed previous exercises
- Understand expression syntax

**Detailed Steps**:

1. **Complete Expression Practice Exercises**
   - Create 20 different expression exercises
   - Include:
     - Date formatting (5 exercises)
     - String operations (5 exercises)
     - Math calculations (5 exercises)
     - Conditional judgment (5 exercises)

2. **Test Each Expression**
   - Test each expression in workflow
   - Record results and explanations

3. **Create Expression Quick Reference**
   - Organize all expressions
   - Categorize and organize
   - Add explanations and examples

4. **Implement Complex Expressions**
   - Combine multiple data sources
   - Perform conditional judgment and calculation
   - Implement nested expressions

**Expected Results**:
- Complete 20 expression exercises
- Create complete expression quick reference
- Implement complex expressions

**Verification Method**:
- Check if each expression is correct
- Verify if quick reference is complete
- Test if complex expressions work

**Expression Practice Exercise Examples**:

| Category | Question | Expression | Description |
|----------|----------|------------|-------------|
| Date | Format current date | `{{ $now.format('YYYY-MM-DD') }}` | ISO date format |
| String | Convert to uppercase | `{{ $json.name.toUpperCase() }}` | String to uppercase |
| Math | Calculate average | `{{ ($json.total / $json.count).toFixed(2) }}` | Keep 2 decimal places |
| Condition | Judge age group | `{{ $json.age >= 18 ? 'adult' : 'minor' }}` | Ternary operator |

**Expression Quick Reference Structure**:

1. **Basic Access**
   - Access fields
   - Access nested fields
   - Access array elements

2. **String Operations**
   - Case conversion
   - String extraction
   - String replacement
   - String splitting

3. **Number Operations**
   - Basic operations
   - Math functions
   - Formatting

4. **Date Operations**
   - Current time
   - Date formatting
   - Date calculation

5. **Conditional Judgment**
   - Ternary operator
   - Logical operators
   - Comparison operators

**Extended Challenge**:
- Research more expression functions
- Create custom expression functions
- Optimize expression performance

**Troubleshooting**:
- **Problem**: Expression syntax error
  - **Solution**: Check syntax, ensure parentheses match
- **Problem**: Expression returns wrong result
  - **Solution**: Check data types, ensure operators are correct

### Exercise 6: Arrays and Batch Processing

**Task Objective**: Understand Split In Batches node function, create workflow that processes large amounts of data, implement error retry mechanism

**Prerequisites**:
- Completed previous exercises
- Understand array processing

**Detailed Steps**:

1. **Create Large Amount of Test Data**
   - Add Manual Trigger node
   - Add Code node to generate 1000 data records

2. **Use Split In Batches Node**
   - Add Split In Batches node
   - Configure batch size: 50
   - Configure batch interval: 1000ms (1 second)

3. **Process Each Batch**
   - Add processing node after Split In Batches
   - Execute operation on each batch

4. **Implement Error Retry**
   - Configure error handling in processing node
   - Use "Continue On Fail" option
   - Add retry logic

5. **Merge Results**
   - Use Item Lists node to merge results
   - Or use Code node to summarize

**Expected Results**:
- Data successfully processed in batches
- Error retry mechanism works
- All data processed

**Verification Method**:
- Check if data is processed in batches
- Verify if error retry is effective
- Confirm all data is processed

**Extended Challenge**:
- Implement intelligent batch size adjustment
- Add processing progress tracking
- Implement parallel batch processing

**Troubleshooting**:
- **Problem**: Batch processing timeout
  - **Solution**: Increase batch interval, reduce batch size
- **Problem**: Data lost
  - **Solution**: Check merge logic, ensure all batches are processed

## Common Questions

**Q1: How to access nested JSON fields?**

A: Use dot (.) to access nested fields:
```javascript
{{ $json.user.profile.name }}
{{ $json.company.departments.Engineering.budget }}
```

**Q2: How to process array data?**

A: Multiple ways:
- Use expression to access: `{{ $json.items[0] }}`
- Use Code node to process: `items.map(item => ...)`
- Use Item Lists node to split or merge

**Q3: How to convert data types in expressions?**

A:
- String to number: `parseInt($json.price)` or `parseFloat($json.price)`
- Number to string: `$json.id.toString()`
- String to date: `new Date($json.dateString)`

**Q4: How to check if field exists?**

A: Use conditional judgment:
```javascript
{{ $json.field ? $json.field : 'default' }}
{{ $json.field || 'default' }}
```

**Q5: How to use multiple conditions in expressions?**

A: Use logical operators:
```javascript
{{ $json.status === 'active' && $json.verified === true }}
{{ $json.role === 'admin' || $json.role === 'moderator' }}
```

**Q6: What is $input in Code node?**

A: `$input` is the object in Code node to access input data:
- `$input.all()`: Get all data items
- `$input.item`: Get current data item
- `$input.first()`: Get first data item

**Q7: How to format dates?**

A: Use expressions:
```javascript
{{ $now.format('YYYY-MM-DD') }}
{{ $json.date.format('YYYY-MM-DD HH:mm:ss') }}
```

**Q8: How to merge multiple data sources?**

A:
- Use Merge node (recommended)
- Use Code node to manually merge
- Use Item Lists node

**Q9: How to handle data conflicts?**

A:
- Configure conflict handling rules in Merge node
- Use Code node to implement custom conflict resolution logic
- Set priority rules

**Q10: How to optimize large data processing performance?**

A:
- Use Split In Batches for batch processing
- Reduce unnecessary field operations
- Use Code node for batch processing
- Optimize expression complexity

## Knowledge Check

### Multiple Choice Questions

1. **How to access nested JSON fields?**
   - A. `{{ $json[user][name] }}`
   - B. `{{ $json.user.name }}`
   - C. `{{ $json->user->name }}`
   - D. `{{ json.user.name }}`
   - **Answer**: B
   - **Explanation**: Use dot (.) to access nested fields.

2. **How to get all input data in Code node?**
   - A. `$input.all()`
   - B. `$input.items`
   - C. `$input.data`
   - D. `$input.list()`
   - **Answer**: A
   - **Explanation**: `$input.all()` returns an array of all input data items.

3. **How to format number to keep 2 decimal places?**
   - A. `{{ $json.price.round(2) }}`
   - B. `{{ $json.price.toFixed(2) }}`
   - C. `{{ $json.price.format(2) }}`
   - D. `{{ round($json.price, 2) }}`
   - **Answer**: B
   - **Explanation**: Use `.toFixed(2)` method to format numbers.

4. **What are the merge modes of Merge node?**
   - A. Only Merge By Index
   - B. Merge By Index and Merge By Key
   - C. Only Append
   - D. Merge By Index, Merge By Key, and Append
   - **Answer**: D
   - **Explanation**: Merge node supports three merge modes.

5. **How to check if field exists?**
   - A. `{{ $json.field !== null }}`
   - B. `{{ $json.field ? $json.field : 'default' }}`
   - C. `{{ $json.field || 'default' }}`
   - D. All of the above
   - **Answer**: D
   - **Explanation**: Multiple ways can be used to check if field exists.

### Short Answer Questions

1. **Explain the basic structure of JSON data in N8N and provide an example of nested JSON.**

   **Sample Answer**:
   N8N uses JSON format to pass data. Basic structure includes json, binary, and error parts. Nested JSON example:
   ```json
   {
     "json": {
       "user": {
         "name": "John",
         "address": {
           "city": "Beijing"
         }
       }
     }
   }
   ```

2. **What's the difference between Set node and Code node? What scenarios are they suitable for?**

   **Sample Answer**:
   - **Set Node**:
     - Simple and easy to use, visual configuration
     - Suitable for simple field operations (add, modify, delete)
     - Suitable for standardizing data format
   - **Code Node**:
     - Flexible and powerful, can write complex logic
     - Suitable for complex data processing
     - Suitable for scenarios requiring loops or conditional judgment

3. **List 5 common expression functions and explain their purposes.**

   **Sample Answer**:
   - `{{ $json.name.toUpperCase() }}`: String to uppercase
   - `{{ $json.price.toFixed(2) }}`: Number keep 2 decimal places
   - `{{ $now.format('YYYY-MM-DD') }}`: Format current date
   - `{{ $json.items.length }}`: Get array length
   - `{{ $json.age >= 18 ? 'adult' : 'minor' }}`: Conditional judgment

4. **How to merge data from multiple data sources? Please explain the steps.**

   **Sample Answer**:
   1. Fetch multiple data sources (use multiple HTTP Request nodes)
   2. Add Merge node
   3. Connect all data sources to Merge node
   4. Select merge mode (Merge By Key, Merge By Index, or Append)
   5. Configure merge key (if using Merge By Key)
   6. Handle data conflicts and missing fields

5. **How to process large amounts of data to avoid timeout?**

   **Sample Answer**:
   1. Use Split In Batches node for batch processing
   2. Set appropriate batch size (e.g., 50 or 100)
   3. Set batch interval time
   4. Use Code node for batch processing
   5. Optimize processing logic, reduce unnecessary operations

### Practice Questions

1. **Create Data Transformation Workflow**
   - Fetch data from API
   - Use Set node to rename fields
   - Use Code node for data calculation
   - Format output data

2. **Implement Data Merging and Filtering**
   - Fetch data from multiple data sources
   - Use Merge node to merge
   - Use IF node to filter
   - Output processed data

3. **Create Expression Quick Reference**
   - Organize common expressions
   - Categorize and organize
   - Add examples and explanations

## Further Reading

### Official Resources

1. **N8N Expression Documentation**
   - URL: https://docs.n8n.io/code/expressions/
   - Content: Expression syntax and function reference

2. **N8N Node Documentation**
   - URL: https://docs.n8n.io/integrations/
   - Content: Detailed documentation of all nodes

3. **JSON Specification**
   - URL: https://www.json.org/
   - Content: Detailed JSON format specification

### Learning Resources

1. **JavaScript Basics**
   - Learn JavaScript syntax
   - Understand array and object operations
   - Master functions and conditional statements

2. **JSON Processing Best Practices**
   - Learn JSON data structure
   - Understand data validation
   - Master data transformation patterns

3. **Data Processing Patterns**
   - Learn ETL (Extract, Transform, Load) patterns
   - Understand data cleaning techniques
   - Master data aggregation methods

### Related Tools and Concepts

1. **Data Transformation Tools**
   - Learn about other data transformation tools
   - Learn data pipeline concepts
   - Understand data stream processing

2. **Expression Language Deep Learning**
   - Research JavaScript expressions
   - Learn functional programming
   - Understand closures and scope

3. **Performance Optimization**
   - Learn data processing performance optimization
   - Understand batch processing strategies
   - Master memory management

### Next Steps

After completing this chapter, it's recommended that you:

1. **Complete All Practice Exercises**
   - Ensure you can handle various data scenarios
   - Master the usage of expression language
   - Understand data transformation and merging methods

2. **Create Data Processing Templates**
   - Organize common data processing patterns
   - Create reusable templates
   - Build personal knowledge base

3. **Optimize Existing Workflows**
   - Improve data processing logic
   - Optimize expression performance
   - Add data validation

4. **Start Chapter 6 Learning**
   - Next chapter will teach you how to implement conditional logic and loop control
   - Learn IF, Switch, Loop and other nodes
   - Get ready to create more complex workflows

---

## Quick Reference

### Common Expressions

| Function | Expression | Description |
|----------|------------|-------------|
| Access Field | `{{ $json.name }}` | Access simple field |
| Access Nested Field | `{{ $json.user.name }}` | Access nested field |
| Access Array Element | `{{ $json.items[0] }}` | Access first array element |
| String to Uppercase | `{{ $json.name.toUpperCase() }}` | String to uppercase |
| Number Formatting | `{{ $json.price.toFixed(2) }}` | Keep 2 decimal places |
| Date Formatting | `{{ $now.format('YYYY-MM-DD') }}` | Format date |
| Conditional Judgment | `{{ $json.age >= 18 ? 'adult' : 'minor' }}` | Ternary operator |
| Array Length | `{{ $json.items.length }}` | Get array length |

### Data Operation Node Comparison

| Node | Use Cases | Complexity | Flexibility |
|------|-----------|------------|-------------|
| Set | Simple field operations | ‚≠ê Simple | ‚≠ê‚≠ê Medium |
| Code | Complex data processing | ‚≠ê‚≠ê‚≠ê Complex | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Highest |
| Function | Quick function writing | ‚≠ê‚≠ê Medium | ‚≠ê‚≠ê‚≠ê Medium |
| Item Lists | Array processing | ‚≠ê‚≠ê Medium | ‚≠ê‚≠ê‚≠ê Medium |
| Merge | Data merging | ‚≠ê‚≠ê Medium | ‚≠ê‚≠ê‚≠ê Medium |

### Data Type Conversion

| Conversion Type | Method | Example |
|----------------|-------|---------|
| String to Number | `parseInt()` / `parseFloat()` | `parseInt($json.price)` |
| Number to String | `.toString()` | `$json.id.toString()` |
| String to Date | `new Date()` | `new Date($json.dateString)` |
| Date to String | `.format()` | `$json.date.format('YYYY-MM-DD')` |

---

**Congratulations on completing Chapter 5! Now you can process and transform various data. Are you ready to learn how to implement conditional logic and loop control to create smarter workflows?** üöÄ

