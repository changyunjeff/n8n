# Chapter 6: How to Implement Conditional Logic and Loop Control?

## Problem Introduction

You've learned how to process and transform data, but you may find that many real-world scenarios require more complex logic: when order status is "pending" execute operation A, when "shipped" execute operation B, when "completed" execute operation C; or need to process a list containing 100 orders, executing the same operation for each order.

"How do I execute different operations based on different conditions? How do I repeatedly process multiple items? How do I handle errors and retries? How do I pause a workflow waiting for manual approval?" These flow control questions might confuse you. But don't worry, N8N provides powerful flow control capabilities, including conditional judgment, loop processing, error handling, and more.

This chapter will explain N8N's flow control capabilities in detail, starting from basic IF and Switch nodes, gradually learning how to use Loop nodes to process array data, master error handling and retry mechanisms, and learn to use Wait nodes to implement workflow pause and resume. Through this chapter, you'll be able to create workflows with complex logic, making automation truly intelligent.

## Core Concepts

### Conditional Judgment Nodes

Conditional judgment is the foundation for implementing branch logic in workflows. N8N provides multiple conditional judgment nodes.

#### IF Node

IF node is used to implement simple binary conditional judgment (true/false).

**Main Functions**:
- Judge data flow based on single condition
- Output two branches: True (meets condition) and False (doesn't meet condition)
- Support multiple comparison operations (equal, not equal, larger, smaller, etc.)

**Use Cases**:
- Simple binary judgment
- Need clear two branches
- Relatively simple conditional logic

**IF Node Structure**:
```
[Data Source] â†’ [IF Node] â†’ [True Branch] â†’ [Process A]
                            â†’ [False Branch] â†’ [Process B]
```

#### Switch Node

Switch node is used to implement multi-condition branch judgment.

**Main Functions**:
- Judge data flow based on multiple conditions
- Output multiple branches: each condition corresponds to one output
- Can set default output (when no condition is met)

**Use Cases**:
- Multiple condition judgments
- Need multiple branches
- Relatively complex conditional logic

**Switch Node Structure**:
```
[Data Source] â†’ [Switch Node] â†’ [Condition 1] â†’ [Process A]
                              â†’ [Condition 2] â†’ [Process B]
                              â†’ [Condition 3] â†’ [Process C]
                              â†’ [Default] â†’ [Process D]
```

#### IF vs Switch Comparison

| Feature | IF Node | Switch Node |
|---------|---------|-------------|
| **Number of Branches** | 2 (True/False) | Multiple (customizable) |
| **Number of Conditions** | 1 condition | Multiple conditions |
| **Use Cases** | Simple binary judgment | Multi-condition judgment |
| **Complexity** | â­ Simple | â­â­ Medium |

### Loop Control Nodes

Loop control is used to repeatedly process multiple data items.

#### Loop Over Items Node

Loop Over Items node is used to iterate through each element in an array.

**Main Functions**:
- Split array into multiple data items
- Execute same operation on each data item
- Support nested loops

**Use Cases**:
- Process order lists
- Batch send emails
- Iterate through array data

**Loop Structure**:
```
[Array Data] â†’ [Loop Over Items] â†’ [Processing Node] â†’ [Output]
```

#### Split In Batches Node

Split In Batches node is used to process large amounts of data in batches.

**Main Functions**:
- Split data into multiple batches
- Control batch size and interval
- Avoid timeout and resource exhaustion

**Use Cases**:
- Process large amounts of data
- Avoid API rate limiting
- Optimize performance

### Error Handling and Retry

Error handling is an important control mechanism in workflows.

#### Continue On Fail Option

Continue On Fail option allows workflow to continue execution when a node fails.

**Main Functions**:
- Don't interrupt workflow when node fails
- Continue executing subsequent nodes
- Can handle errors in subsequent nodes

**Use Cases**:
- Non-critical operations
- Need fault tolerance
- Partial failures in batch processing

#### Error Retry Mechanism

N8N supports automatic retry of failed nodes.

**Configuration Method**:
- Configure retry count in node settings
- Set retry interval
- Configure retry conditions

### Workflow Pause and Resume

Wait node is used to pause workflow execution and wait for external events.

**Main Functions**:
- Pause workflow execution
- Wait for manual approval
- Wait for external event trigger

**Use Cases**:
- Processes requiring manual approval
- Wait for external system response
- Scheduled waiting

## Detailed Tutorial

### Step 1: Use IF Node to Implement Conditional Judgment

IF node is the most basic conditional judgment node.

#### 1.1 Add IF Node

1. **Add IF Node**
   - Add IF node in workflow
   - Connect to data source

2. **Configure Condition**
   - **Condition**: Select condition type
   - **Value 1**: `{{ $json.status }}`
   - **Operation**: Select operator (e.g., `equal`, `not equal`, `larger`, etc.)
   - **Value 2**: `active`

3. **Connect Branches**
   - **True Branch**: Data that meets condition
   - **False Branch**: Data that doesn't meet condition

[Screenshot location: IF node configuration interface]

#### 1.2 Condition Operators

IF node supports multiple operators:

| Operator | Description | Example |
|----------|-------------|---------|
| **Equal** | Equal to | `status === 'active'` |
| **Not Equal** | Not equal to | `status !== 'inactive'` |
| **Larger** | Larger than | `age > 18` |
| **Smaller** | Smaller than | `price < 100` |
| **Larger Equal** | Larger than or equal to | `score >= 60` |
| **Smaller Equal** | Smaller than or equal to | `quantity <= 10` |
| **Contains** | Contains | `name.contains('John')` |
| **Not Contains** | Not contains | `email.notContains('test')` |
| **Exists** | Exists | `field !== undefined` |
| **Not Exists** | Not exists | `field === undefined` |

#### 1.3 Combine Conditions

IF node supports combining multiple conditions:

**AND Condition** (all conditions must be met):
- Configure multiple conditions, all select True branch

**OR Condition** (any condition can be met):
- Use expression: `{{ $json.status === 'active' || $json.verified === true }}`

### Step 2: Use Switch Node to Implement Multi-Branch

Switch node is used to implement multiple conditional branches.

#### 2.1 Add Switch Node

1. **Add Switch Node**
   - Add Switch node in workflow
   - Connect to data source

2. **Configure Conditions**
   - Click "Add Rule" to add condition
   - Configure for each condition:
     - **Value**: `{{ $json.status }}`
     - **Operation**: Select operator
     - **Output**: Select output number

3. **Set Default Output**
   - Configure default output (optional)
   - Use default output when no condition is met

[Screenshot location: Switch node configuration interface]

#### 2.2 Switch Node Example

**Scenario**: Execute different operations based on order status

**Configuration**:
- **Condition 1**: `{{ $json.status }}` equals `pending` â†’ Output 1 (send pending notification)
- **Condition 2**: `{{ $json.status }}` equals `shipped` â†’ Output 2 (send shipped notification)
- **Condition 3**: `{{ $json.status }}` equals `completed` â†’ Output 3 (send completed notification)
- **Default Output**: Output 4 (handle unknown status)

### Step 3: Use Loop Over Items to Process Arrays

Loop Over Items node is used to iterate through array data.

#### 3.1 Add Loop Over Items Node

1. **Add Loop Over Items Node**
   - Add Loop Over Items node in workflow
   - Connect to data source containing array

2. **Configure Loop**
   - Node will automatically identify array field
   - Or manually specify array field: `{{ $json.orders }}`

3. **Add Processing Node**
   - Add processing node after Loop node
   - Processing node will execute for each array element

[Screenshot location: Loop Over Items node configuration]

#### 3.2 Data Processing in Loop

In a loop, each data item is independent:

**Input Data**:
```json
{
  "orders": [
    {"id": 1, "amount": 100},
    {"id": 2, "amount": 200},
    {"id": 3, "amount": 300}
  ]
}
```

**After Loop** (each data item):
```json
{"id": 1, "amount": 100}
{"id": 2, "amount": 200}
{"id": 3, "amount": 300}
```

#### 3.3 Nested Loops

Nested loops can be implemented:

```
[Data Source] â†’ [Loop 1] â†’ [Process 1] â†’ [Loop 2] â†’ [Process 2] â†’ [Output]
```

### Step 4: Implement Error Handling and Retry

Error handling is an important guarantee for workflow stability.

#### 4.1 Use Continue On Fail

1. **Configure Node**
   - Select node that may fail
   - Check "Continue On Fail" in node settings

2. **Handle Errors**
   - Check for errors in subsequent nodes
   - Use IF node to check if there's error: `{{ $json.error }}`

3. **Record Errors**
   - Use Code node to record error information
   - Or send error notification

#### 4.2 Configure Retry Mechanism

1. **Node Settings**
   - Find "Retry" option in node settings
   - Configure retry count (e.g., 3 times)
   - Configure retry interval (e.g., 1000ms)

2. **Retry Conditions**
   - Can configure retry conditions
   - Only retry when conditions are met

#### 4.3 Error Notification

Create error notification mechanism:

1. **Detect Errors**
   - Use IF node to detect errors
   - Condition: `{{ $json.error }}` exists

2. **Send Notification**
   - Add notification node in error branch
   - Send email, Slack message, etc.

### Step 5: Use Wait Node to Pause Workflow

Wait node is used to pause workflow and wait for external events.

#### 5.1 Add Wait Node

1. **Add Wait Node**
   - Add Wait node in workflow
   - Connect to location that needs to pause

2. **Configure Wait Method**
   - **Wait for Webhook**: Wait for Webhook trigger
   - **Wait for Time**: Wait for specified time
   - **Wait for File**: Wait for file to appear

#### 5.2 Wait for Webhook Trigger

1. **Configure Wait Node**
   - Select "Wait for Webhook"
   - Configure Webhook path

2. **Trigger Resume**
   - External system calls Webhook URL
   - Workflow automatically resumes execution

#### 5.3 Wait for Manual Approval

1. **Configure Wait Node**
   - Select "Wait for Webhook"
   - Generate Webhook URL

2. **Approval Process**
   - Send approval request (email, Slack, etc.)
   - Include approval link (Webhook URL)
   - After approval/rejection, call Webhook
   - Workflow continues execution based on result

## Practice Exercises

### Exercise 1: Conditional Judgment Basics

**Task Objective**: Create a workflow that executes 3 different paths based on different input values, using IF and Switch nodes

**Prerequisites**:
- N8N installed and running
- Understand basic conditional judgment concepts

**Detailed Steps**:

1. **Create Test Data**
   - Add Manual Trigger node
   - Add Set node, create test data:
     - `status`: `pending`, `shipped`, `completed` (test separately)

2. **Use IF Node to Implement Simple Condition**
   - Add IF node
   - Configure condition: `{{ $json.status }}` equals `pending`
   - True branch: Add Set node, set `action: "send_pending_notification"`
   - False branch: Add another IF node, check `shipped`
   - Implement 3 branches

3. **Use Switch Node to Implement Multi-Branch**
   - Add Switch node
   - Configure 3 conditions:
     - `pending` â†’ Output 1
     - `shipped` â†’ Output 2
     - `completed` â†’ Output 3
   - Each output connects to different processing node

4. **Compare Two Methods**
   - Execute both workflows
   - Compare complexity and maintainability
   - Record applicable scenarios

**Expected Results**:
- Successfully implement 3 different execution paths
- Both IF and Switch nodes work correctly
- Complete comparison analysis

**Verification Method**:
- Test different input values
- Check if each branch executes correctly
- Verify if comparison analysis is reasonable

**Comparison Analysis Table**:

| Feature | IF Node | Switch Node |
|---------|---------|-------------|
| Configuration Complexity | Higher (needs nesting) | Lower (direct configuration) |
| Readability | Medium | High |
| Maintainability | Medium | High |
| Use Cases | Simple binary judgment | Multi-condition judgment |

**Extended Challenge**:
- Implement 4 or more branches
- Add default branch handling
- Implement condition combination (AND/OR)

**Troubleshooting**:
- **Problem**: Conditional judgment inaccurate
  - **Solution**: Check data types, ensure comparison value types are consistent
- **Problem**: Branch not executed
  - **Solution**: Check condition configuration, ensure conditional logic is correct

### Exercise 2: Nested Condition Practice

**Task Objective**: Create a complex conditional judgment workflow, implement 3-layer nested conditional logic, draw conditional decision tree

**Prerequisites**:
- Completed Exercise 1
- Understand nested condition concepts

**Detailed Steps**:

1. **Design Conditional Logic**
   - Define 3 layers of conditions:
     - Layer 1: User type (admin/user/guest)
     - Layer 2: Order status (pending/shipped/completed)
     - Layer 3: Order amount (>1000/500-1000/<500)

2. **Implement Nested Conditions**
   - Layer 1: Use Switch node to judge user type
   - Layer 2: Add Switch node in each user type branch to judge order status
   - Layer 3: Add IF node in each order status branch to judge order amount

3. **Draw Conditional Decision Tree**
   - Use charting tool to draw decision tree
   - Label conditions and operations for each branch
   - Label all possible paths

4. **Test All Condition Combinations**
   - Create test data covering all combinations
   - Execute workflow
   - Verify each path executes correctly

**Expected Results**:
- Successfully implement 3-layer nested conditions
- Complete conditional decision tree
- All condition combinations pass testing

**Verification Method**:
- Check if decision tree is complete
- Test all possible condition combinations
- Verify execution results of each path

**Conditional Decision Tree Example**:

```
User Type
â”œâ”€ admin
â”‚  â”œâ”€ pending
â”‚  â”‚  â”œâ”€ >1000 â†’ Operation A1
â”‚  â”‚  â””â”€ <=1000 â†’ Operation A2
â”‚  â”œâ”€ shipped â†’ Operation A3
â”‚  â””â”€ completed â†’ Operation A4
â”œâ”€ user
â”‚  â”œâ”€ pending â†’ Operation B1
â”‚  â””â”€ shipped â†’ Operation B2
â””â”€ guest â†’ Operation C1
```

**Extended Challenge**:
- Implement 4 or more layers of nesting
- Optimize conditional logic, reduce nesting depth
- Use Code node to implement complex conditional judgment

**Troubleshooting**:
- **Problem**: Nesting too deep, difficult to maintain
  - **Solution**: Consider using Code node or refactoring logic
- **Problem**: Condition combinations missed
  - **Solution**: Use decision table to ensure all combinations are covered

### Exercise 3: Loop Processing Practice

**Task Objective**: Create a workflow that processes an array containing 100 items, use Loop Over Items node to iterate, add progress tracking and error handling

**Prerequisites**:
- Completed previous exercises
- Understand loop processing concepts

**Detailed Steps**:

1. **Create Test Data**
   - Add Manual Trigger node
   - Add Code node to generate array of 100 items:
   ```javascript
   const items = [];
   for (let i = 1; i <= 100; i++) {
     items.push({
       json: {
         id: i,
         name: `Item ${i}`,
         status: Math.random() > 0.8 ? 'error' : 'ok',
         value: Math.floor(Math.random() * 1000)
       }
     });
   }
   return items;
   ```

2. **Use Loop Over Items Node**
   - Add Loop Over Items node
   - Node will automatically identify array
   - Or manually specify: `{{ $json }}`

3. **Process Each Item**
   - Add processing node after Loop node
   - Execute operation on each item (e.g., send notification, update status, etc.)

4. **Add Progress Tracking**
   - Use Code node to track progress:
   ```javascript
   const current = $input.item.json.id;
   const total = 100;
   const progress = (current / total * 100).toFixed(1);
   
   return [{
     json: {
       ...$input.item.json,
       progress: progress + '%',
       current: current,
       total: total
     }
   }];
   ```

5. **Add Error Handling**
   - Configure "Continue On Fail" in processing node
   - Add IF node to detect errors
   - Record error information

**Expected Results**:
- Successfully process 100 items
- Progress tracking works correctly
- Error handling mechanism effective

**Verification Method**:
- Check if all items are processed
- Verify if progress information is accurate
- Confirm error items are correctly recorded

**Extended Challenge**:
- Implement parallel processing (using Split In Batches)
- Add processing statistics (success/failure count)
- Implement resume from failure point

**Troubleshooting**:
- **Problem**: Loop processing timeout
  - **Solution**: Use Split In Batches for batch processing
- **Problem**: Progress tracking inaccurate
  - **Solution**: Check progress calculation logic, ensure correct

### Exercise 4: Condition + Loop Combination Project

**Task Objective**: Create a workflow that fetches order list from API, iterate through each order, execute different operations based on order status, count number of orders in each status

**Prerequisites**:
- Completed previous exercises
- Have an available API (can use test API)

**Detailed Steps**:

1. **Fetch Order List**
   - Add Schedule Trigger node
   - Add HTTP Request node
   - Configure API URL (e.g.: `https://jsonplaceholder.typicode.com/posts`)
   - Or use test data

2. **Use Loop Over Items to Iterate Orders**
   - Add Loop Over Items node
   - Iterate through order array

3. **Branch Based on Order Status**
   - Add Switch node after Loop node
   - Configure multiple conditions:
     - `pending` â†’ Send pending notification
     - `shipped` â†’ Send shipped notification
     - `completed` â†’ Send completed notification
     - Default â†’ Record unknown status

4. **Count Order Numbers**
   - Add Code node after Switch node
   - Count number of each status:
   ```javascript
   const items = $input.all();
   const stats = {
     pending: 0,
     shipped: 0,
     completed: 0,
     unknown: 0
   };
   
   items.forEach(item => {
     const status = item.json.status || 'unknown';
     if (stats[status] !== undefined) {
       stats[status]++;
     } else {
       stats.unknown++;
     }
   });
   
   return [{
     json: {
       ...stats,
       total: items.length
     }
   }];
   ```

5. **Output Statistics**
   - Add output node (e.g., Email, Slack)
   - Send statistics report

**Expected Results**:
- Successfully iterate through all orders
- Correctly branch based on status
- Statistics accurate

**Verification Method**:
- Check if each order is processed
- Verify if branching is correct
- Confirm statistics count is accurate

**Extended Challenge**:
- Add order amount statistics
- Implement order grouping processing
- Add abnormal order alerts

**Troubleshooting**:
- **Problem**: Some orders fail in loop processing
  - **Solution**: Add error handling, use Continue On Fail
- **Problem**: Statistics inaccurate
  - **Solution**: Check statistics logic, ensure correct counting

### Exercise 5: Error Handling and Retry Logic

**Task Objective**: Create a workflow that may fail, implement error capture and retry mechanism, create error notification mechanism

**Prerequisites**:
- Completed previous exercises
- Understand error handling concepts

**Detailed Steps**:

1. **Create Workflow That May Fail**
   - Add Manual Trigger node
   - Add HTTP Request node
   - Use a URL that may fail (e.g.: `https://httpstat.us/500`)

2. **Configure Error Handling**
   - Configure "Continue On Fail" in HTTP Request node
   - Add IF node to detect errors:
     - Condition: `{{ $json.error }}` exists

3. **Implement Retry Mechanism**
   - Configure retry in HTTP Request node:
     - Retry count: 3
     - Retry interval: 1000ms

4. **Create Error Notification Mechanism**
   - Add notification node in error branch
   - Send error information to Email or Slack
   - Include error details and retry information

5. **Record Error Logs**
   - Add Code node to record errors:
   ```javascript
   const error = $input.item.json.error;
   return [{
     json: {
       timestamp: new Date().toISOString(),
       error: error.message || error,
       retryCount: $input.item.json.retryCount || 0
     }
   }];
   ```

**Expected Results**:
- Errors correctly captured
- Retry mechanism works correctly
- Error notifications successfully sent

**Verification Method**:
- Test failure scenarios
- Verify if retry executes
- Check if error notifications received

**Extended Challenge**:
- Implement intelligent retry (decide whether to retry based on error type)
- Add error classification and statistics
- Implement error recovery mechanism

**Troubleshooting**:
- **Problem**: Retry not effective
  - **Solution**: Check retry configuration, ensure node supports retry
- **Problem**: Error notification not sent
  - **Solution**: Check error detection logic, ensure correctly identifying errors

### Exercise 6: Workflow Pause and Resume

**Task Objective**: Create a workflow that requires manual approval, use Wait node to pause execution, implement approval/rejection branch logic

**Prerequisites**:
- Completed previous exercises
- Understand Wait node concepts

**Detailed Steps**:

1. **Create Workflow**
   - Add Manual Trigger node
   - Add Set node, create approval request data:
     - `requestId`: Unique ID
     - `requester`: Requester
     - `amount`: Amount
     - `reason`: Request reason

2. **Send Approval Request**
   - Add Email node or Slack node
   - Send approval notification
   - Include approval link (Webhook URL)

3. **Add Wait Node**
   - Add Wait node
   - Select "Wait for Webhook"
   - Configure Webhook path: `/approval/{{ $json.requestId }}`
   - Record Webhook URL

4. **Implement Approval Branch**
   - Add Switch node after Wait node
   - Branch based on approval result:
     - `approved` â†’ Execute operation (e.g., process request)
     - `rejected` â†’ Reject operation (e.g., send rejection notification)
     - Default â†’ Timeout handling

5. **Test Workflow**
   - Execute workflow
   - Use Webhook URL to simulate approval
   - Verify branch logic

**Expected Results**:
- Workflow successfully pauses
- Approval request successfully sent
- After approval, correctly resumes and executes corresponding branch

**Verification Method**:
- Check if Wait node pauses
- Verify if Webhook URL is accessible
- Test both approval and rejection scenarios

**Extended Challenge**:
- Add approval timeout handling
- Implement multi-level approval
- Add approval history records

**Troubleshooting**:
- **Problem**: Wait node doesn't pause
  - **Solution**: Check Wait node configuration, ensure correct wait method selected
- **Problem**: Webhook cannot trigger
  - **Solution**: Check Webhook URL, ensure N8N is accessible

## Common Questions

**Q1: What's the difference between IF node and Switch node?**

A:
- **IF Node**: Used for binary judgment (true/false), only 2 output branches
- **Switch Node**: Used for multi-condition judgment, can have multiple output branches
- **Selection Recommendation**: Use IF for simple binary judgment, use Switch for multiple conditions

**Q2: How to access current index in loop?**

A: In Loop Over Items, can use expression:
```javascript
{{ $input.item.json.__index }}  // Current index (starts from 0)
{{ $input.item.json.__index + 1 }}  // Index starting from 1
```

**Q3: How to break out of loop?**

A: N8N's Loop node processes all items, cannot directly break. If need to end early, can:
- Use Code node to filter data, only process needed items
- Use IF node to skip unneeded items

**Q4: What's the difference between Continue On Fail and retry?**

A:
- **Continue On Fail**: After node fails, continue executing subsequent nodes, no retry
- **Retry**: After node fails, automatically retry, only continue or stop after retry fails
- Can use together: After retry fails, if Continue On Fail is set, will continue executing

**Q5: How to implement parallel processing?**

A:
- Use multiple parallel branches (not connected, all start from same node)
- Use Split In Batches for batch parallel processing
- Use Code node to implement parallel logic

**Q6: Will Wait node consume resources?**

A: Wait node pauses workflow execution but doesn't consume large resources. Workflow will wait until trigger condition is met.

**Q7: How to implement condition combination (AND/OR)?**

A:
- **AND**: Use expression in IF node: `{{ $json.status === 'active' && $json.verified === true }}`
- **OR**: Use expression in IF node: `{{ $json.role === 'admin' || $json.role === 'moderator' }}`
- Or use multiple IF nodes nested

**Q8: How to handle errors in loop?**

A:
- Configure "Continue On Fail" in processing node
- Add error detection node after loop
- Record error information, continue processing other items

**Q9: How to count loop processing results?**

A:
- Add Code node after loop
- Use `$input.all()` to get all processing results
- Perform statistical calculation (success count, failure count, etc.)

**Q10: How to get Wait node's Webhook URL?**

A:
- Webhook URL will be displayed in Wait node configuration
- Or use expression: `{{ $workflow.webhookUrl }}`
- Ensure N8N is accessible (configure correct domain and port)

## Knowledge Check

### Multiple Choice Questions

1. **What's the main difference between IF node and Switch node?**
   - A. IF node is simpler
   - B. Switch node supports multiple branches
   - C. IF node can only judge true/false
   - D. All of the above
   - **Answer**: D
   - **Explanation**: IF node is for binary judgment, Switch node supports multiple conditional branches.

2. **What is the function of Loop Over Items node?**
   - A. Merge arrays
   - B. Iterate through each element in array
   - C. Filter arrays
   - D. Sort arrays
   - **Answer**: B
   - **Explanation**: Loop Over Items node is used to iterate through each element in an array.

3. **What is the function of Continue On Fail option?**
   - A. Automatic retry
   - B. Continue execution when node fails
   - C. Ignore errors
   - D. Stop workflow
   - **Answer**: B
   - **Explanation**: Continue On Fail allows workflow to continue executing subsequent nodes when a node fails.

4. **What can Wait node wait for?**
   - A. Only wait for time
   - B. Only wait for Webhook
   - C. Can wait for Webhook, time, or file
   - D. Cannot wait
   - **Answer**: C
   - **Explanation**: Wait node supports waiting for Webhook, time, or file.

5. **How to implement nested conditional judgment?**
   - A. Can only use Switch node
   - B. Can only use IF node
   - C. Can use IF node or Switch node nested
   - D. Cannot implement nesting
   - **Answer**: C
   - **Explanation**: Can use IF node or Switch node to implement nested conditional judgment.

### Short Answer Questions

1. **Explain the difference between IF node and Switch node, and explain their respective use cases.**

   **Sample Answer**:
   - **IF Node**:
     - Used for binary judgment (true/false)
     - Only 2 output branches
     - Suitable for simple conditional judgment
     - Example: Judge if order is completed
   - **Switch Node**:
     - Used for multi-condition judgment
     - Can have multiple output branches
     - Suitable for complex conditional judgment
     - Example: Execute different operations based on order status

2. **How to use Loop Over Items node to process array data? Please explain the steps.**

   **Sample Answer**:
   1. Ensure data source contains array field
   2. Add Loop Over Items node
   3. Node will automatically identify array, or manually specify array field
   4. Add processing node after Loop node
   5. Processing node will execute for each array element
   6. After all elements processed, continue executing subsequent nodes

3. **How to implement error handling and retry mechanism? Please list main steps.**

   **Sample Answer**:
   1. Configure "Continue On Fail" in nodes that may fail
   2. Configure retry count and retry interval
   3. Detect errors in subsequent nodes (using IF node)
   4. Record error information (using Code node)
   5. Send error notifications (using Email or Slack node)

4. **What wait methods does Wait node have? What scenarios are they suitable for?**

   **Sample Answer**:
   - **Wait for Webhook**:
     - Wait for external Webhook trigger
     - Suitable for manual approval, external system response
   - **Wait for Time**:
     - Wait for specified time
     - Suitable for scheduled delay, batch processing interval
   - **Wait for File**:
     - Wait for file to appear
     - Suitable for file processing scenarios

5. **How to implement condition + loop combination? Please provide a real-world example.**

   **Sample Answer**:
   Example: Process order list, execute different operations based on order status
   1. Fetch order list (array)
   2. Use Loop Over Items to iterate through each order
   3. Use Switch node in loop to branch based on order status
   4. Each status branch executes different operation
   5. After loop ends, count processing results

### Practice Questions

1. **Create Conditional Judgment Workflow**
   - Implement at least 3 conditional branches
   - Use IF and Switch nodes
   - Test all branches

2. **Implement Loop Processing**
   - Process array containing multiple items
   - Add progress tracking
   - Implement error handling

3. **Create Approval Workflow**
   - Use Wait node to pause
   - Implement approval/rejection branch
   - Test complete process

## Further Reading

### Official Resources

1. **N8N Conditional Node Documentation**
   - URL: https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.if/
   - Content: Detailed documentation of IF and Switch nodes

2. **N8N Loop Node Documentation**
   - URL: https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.splitinbatches/
   - Content: Detailed documentation of loop processing nodes

3. **N8N Error Handling Documentation**
   - URL: https://docs.n8n.io/workflows/error-handling/
   - Content: Best practices for error handling and retry

### Learning Resources

1. **Flow Control Patterns**
   - Learn common flow control patterns
   - Understand conditional judgment best practices
   - Master loop processing optimization methods

2. **Error Handling Strategies**
   - Learn error handling design patterns
   - Understand retry strategies
   - Master error recovery mechanisms

3. **Workflow Design Patterns**
   - Learn workflow design patterns
   - Understand organization of complex logic
   - Master maintainability design principles

### Related Tools and Concepts

1. **Flow Control Theory**
   - Learn basic concepts of conditional judgment and loops
   - Understand flowchart drawing methods
   - Master decision tree design

2. **Error Handling Best Practices**
   - Learn error classification and handling strategies
   - Understand retry mechanism design
   - Master error monitoring and alerting

3. **Workflow Optimization**
   - Learn workflow performance optimization
   - Understand parallel processing strategies
   - Master resource management methods

### Next Steps

After completing this chapter, it's recommended that you:

1. **Complete All Practice Exercises**
   - Ensure you can implement conditional judgment and loop control
   - Master error handling and retry mechanisms
   - Understand workflow pause and resume

2. **Optimize Existing Workflows**
   - Improve conditional judgment logic
   - Optimize loop processing performance
   - Add error handling mechanisms

3. **Create Complex Workflows**
   - Combine conditions, loops, error handling
   - Create workflows for real business scenarios
   - Accumulate practical experience

4. **Start Chapter 7 Learning**
   - Next chapter will teach you how to debug and optimize workflows
   - Learn debugging tools and methods
   - Get ready to optimize your workflow performance

---

## Quick Reference

### Conditional Node Comparison

| Node | Number of Branches | Use Cases | Complexity |
|------|-------------------|-----------|------------|
| IF | 2 (True/False) | Simple binary judgment | â­ Simple |
| Switch | Multiple (customizable) | Multi-condition judgment | â­â­ Medium |

### Loop Node Comparison

| Node | Function | Use Cases |
|------|----------|-----------|
| Loop Over Items | Iterate through array elements | Process array data |
| Split In Batches | Process data in batches | Process large amounts of data |

### Common Condition Operators

| Operator | Description | Example |
|----------|-------------|---------|
| Equal | Equal to | `status === 'active'` |
| Not Equal | Not equal to | `status !== 'inactive'` |
| Larger | Larger than | `age > 18` |
| Contains | Contains | `name.contains('John')` |
| Exists | Exists | `field !== undefined` |

### Error Handling Options

| Option | Function | Use Cases |
|--------|----------|-----------|
| Continue On Fail | Continue after failure | Non-critical operations |
| Retry | Automatic retry | Temporary errors |
| Error Trigger | Error trigger | Global error handling |

---

**Congratulations on completing Chapter 6! Now you can implement complex conditional logic and loop control. Are you ready to learn how to debug and optimize workflows to make them run faster and more stable?** ðŸš€

